/*
 * Full Waveform Inversion (2D visco-elastic SH problem)  
 *
 * Daniel Koehn
 * Kiel, 12/12/2017
 */

#include "fd.h"

void FWI_SH_visc(){

/* global variables */
/* ---------------- */

/* forward modelling */
extern int MYID, FDORDER, NX, NY, NT, L, READMOD, QUELLART, RUN_MULTIPLE_SHOTS, TIME_FILT, READREC;
extern int LOG, SEISMO, N_STREAMER, FW, NXG, NYG, IENDX, IENDY, NTDTINV, IDXI, IDYI, NXNYI, INV_STF, DTINV;
extern float FC_SPIKE_1, FC_SPIKE_2, FC, FC_START, TIME, DT;
extern char LOG_FILE[STRING_SIZE], MFILE[STRING_SIZE];
extern FILE *FP;

/* gravity modelling/inversion */
extern int GRAVITY, NZGRAV, NGRAVB, GRAV_TYPE, BACK_DENSITY;
extern char GRAV_DATA_OUT[STRING_SIZE], GRAV_DATA_IN[STRING_SIZE], GRAV_STAT_POS[STRING_SIZE], DFILE[STRING_SIZE];
extern float LAM_GRAV, GAMMA_GRAV, LAM_GRAV_GRAD, L2_GRAV_IT1;

/* full waveform inversion */
extern int GRAD_METHOD, NLBFGS, ITERMAX, IDX, IDY, INVMAT1, EPRECOND, PCG_BETA, LNORM;
extern int GRAD_FORM, POS[3], QUELLTYPB, MIN_ITER, MODEL_FILTER, INV_MOD_OUT, ROWI;
extern int GRAD_FILTER, MODEL_FILTER, FILT_SIZE, FILT_SIZE_GRAD;
extern float FC_END, PRO, C_vs, C_rho, C_taus, C_vs_min, C_rho_min, C_taus_min;
extern char MISFIT_LOG_FILE[STRING_SIZE], JACOBIAN[STRING_SIZE];
extern char *FILEINP1;

/* local variables */
int ns, nseismograms=0, nt, nd, fdo3, j, i, iter, h, hin, iter_true, SHOTINC, s=0;
int buffsize, ntr=0, ntr_loc=0, ntr_glob=0, nsrc=0, nsrc_loc=0, nsrc_glob=0, ishot, nshots=0, itestshot;

float sum, eps_scale, opteps_vp, opteps_vs, opteps_rho, opteps_ts, Vs_max, rho_max, taus_max, Vs_sum, rho_sum, taus_sum;
float Vs_min, rho_min, taus_min, Vs_avg, rho_avg;
char *buff_addr, ext[10], *fileinp, jac[225], source_signal_file[STRING_SIZE];

double time1, time2, time7, time8, time_av_v_update=0.0, time_av_s_update=0.0, time_av_v_exchange=0.0; 
double time_av_s_exchange=0.0, time_av_timestep=0.0;
	
double L2sum, *L2t;
	
float ** taper_coeff, * epst1, *hc=NULL;
int * DTINV_help;

MPI_Request *req_send, *req_rec;
MPI_Status  *send_statuses, *rec_statuses;

/* Variables for step length calculation */
int step1, step3=0;
float eps_true, tmp;

/* Variables for the L-BFGS method */
float * rho_LBFGS, * alpha_LBFGS, * beta_LBFGS; 
float * y_LBFGS, * s_LBFGS, * q_LBFGS, * r_LBFGS;
int NLBFGS_class, LBFGS_pointer, NLBFGS_vec;

/* Variables for PCG */
float * PCG_old, * PCG_new, * PCG_dir;
int PCG_class, PCG_vec;

/* Variables for energy weighted gradient */
float ** Ws, **Wr, **We;

/* parameters for FWI-workflow */
int stagemax=0, nstage;

/*vector for abort criterion*/
double * L2_hist=NULL;

/* help variable for MIN_ITER */
int min_iter_help=0;

/* parameters for gravity inversion */
float * gz_mod, * gz_res;
float ** gravpos=NULL, ** rho_grav=NULL, ** rho_grav_ext=NULL;
float ** grad_grav=NULL;
int ngrav=0, nxgrav, nygrav;
float L2_grav, FWImax, GRAVmax, FWImax_all, GRAVmax_all ;
char jac_grav[STRING_SIZE];

/* parameters for random number generation */
int ra, ra1;

FILE *FPL2, *FP_stage, *FP_GRAV, *LAMBDA;

if (MYID == 0){
   time1=MPI_Wtime(); 
   clock();
}

/* open log-file (each PE is using different file) */
/*	fp=stdout; */
sprintf(ext,".%i",MYID);  
strcat(LOG_FILE,ext);

if ((MYID==0) && (LOG==1)) FP=stdout;
else FP=fopen(LOG_FILE,"w");
fprintf(FP," This is the log-file generated by PE %d \n\n",MYID);

/* ----------------------- */
/* define FD grid geometry */
/* ----------------------- */

/* domain decomposition */
initproc();

NT=iround(TIME/DT); /* number of timesteps */

/* output of parameters to log-file or stdout */
if (MYID==0) write_par(FP);

/* NXG, NYG denote size of the entire (global) grid */
NXG=NX;
NYG=NY;

/* In the following, NX and NY denote size of the local grid ! */
NX = IENDX;
NY = IENDY;

NTDTINV=ceil((float)NT/(float)DTINV);		/* round towards next higher integer value */

/* save every IDXI and IDYI spatial point during the forward modelling */
IDXI=1;
IDYI=1;

NXNYI=(NX/IDXI)*(NY/IDYI);
SHOTINC=1;

/* use only every DTINV time sample for the inversion */
DTINV_help=ivector(1,NT);

/* read parameters from workflow-file (stdin) */
FP_stage=fopen(FILEINP1,"r");
if(FP_stage==NULL) {
	if (MYID == 0){
		printf("\n==================================================================\n");
		printf(" Cannot open Denise workflow input file %s \n",FILEINP1);
		printf("\n==================================================================\n\n");
		err(" --- ");
	}
}

/* estimate number of lines in FWI-workflow */
i=0;
stagemax=0;
while ((i=fgetc(FP_stage)) != EOF)
if (i=='\n') ++stagemax;
rewind(FP_stage);
stagemax--;
fclose(FP_stage);

/* define data structures for PSV problem */
struct waveSH;
struct waveSH_PML;
struct matSH;
struct fwiSH;
struct mpiPSV;
struct seisSH;
struct seisSHfwi;
struct acq;

nd = FDORDER/2 + 1;
fdo3 = 2*nd;
buffsize=2.0*2.0*fdo3*(NX +NY)*sizeof(MPI_FLOAT);

/* allocate buffer for buffering messages */
buff_addr=malloc(buffsize);
if (!buff_addr) err("allocation failure for buffer for MPI_Bsend !");
MPI_Buffer_attach(buff_addr,buffsize);

/* allocation for request and status arrays */
req_send=(MPI_Request *)malloc(REQUEST_COUNT*sizeof(MPI_Request));
req_rec=(MPI_Request *)malloc(REQUEST_COUNT*sizeof(MPI_Request));
send_statuses=(MPI_Status *)malloc(REQUEST_COUNT*sizeof(MPI_Status));
rec_statuses=(MPI_Status *)malloc(REQUEST_COUNT*sizeof(MPI_Status));

/* --------- add different modules here ------------------------ */
ns=NT;	/* in a FWI one has to keep all samples of the forward modeled data
	at the receiver positions to calculate the adjoint sources and to do 
	the backpropagation; look at function saveseis_glob.c to see that every
	NDT sample for the forward modeled wavefield is written to su files*/

if (SEISMO && (READREC!=2)){

   acq.recpos=receiver(FP, &ntr, ishot);
   acq.recswitch = ivector(1,ntr);
   acq.recpos_loc = splitrec(acq.recpos,&ntr_loc, ntr, acq.recswitch);
   ntr_glob=ntr;
   ntr=ntr_loc;
   
}

if(READREC!=2){

   /* Memory for seismic data */
   alloc_seisSH(ntr,ns,&seisSH);

   /* Memory for FWI seismic data */ 
   alloc_seisSHfwi(ntr,ntr_glob,ns,&seisSHfwi);
   
   /* Memory for full data seismograms */
   alloc_seisSHfull(&seisSH,ntr_glob);

}

/* memory allocation for abort criterion*/
L2_hist = dvector(1,1000);

/* estimate memory requirement of the variables in megabytes*/
	
switch (SEISMO){
case 1 : /* particle velocities only */
	nseismograms=1;	
	break;	
}		

/* calculate memory requirements for PSV forward problem */
mem_fwiPSV(nseismograms,ntr,ns,fdo3,nd,buffsize,ntr_glob);

/* Define gradient formulation */
/* GRAD_FORM = 2 - stress-velocity gradients for symmetrized impedance matrix */
GRAD_FORM = 2;

if(GRAVITY==1 || GRAVITY==2){
  
  if(GRAV_TYPE == 1){
  sprintf(GRAV_DATA_OUT, "./gravity/grav_mod.dat"); /* output file of gravity data */
  sprintf(GRAV_DATA_IN, "./gravity/grav_field.dat");  /* input file of gravity data */
  }
  if(GRAV_TYPE == 2){
  sprintf(GRAV_DATA_OUT, "./gravity/grav_grad_mod.dat"); /* output file of gravity gradient data */
  sprintf(GRAV_DATA_IN, "./gravity/grav_grad_field.dat");  /* input file of gravity gradientdata */
  }
  sprintf(GRAV_STAT_POS, "./gravity/grav_stat.dat"); /* file with station positions for gravity modelling */

  /* size of the extended gravity model */
  nxgrav = NXG + 2*NGRAVB;
  nygrav = NYG + NGRAVB;

}

/* allocate memory for SH forward problem */
alloc_SH(&waveSH,&waveSH_PML);

/* calculate damping coefficients for CPMLs (SH problem)*/
if(FW>0){PML_pro_SH(waveSH_PML.d_x, waveSH_PML.K_x, waveSH_PML.alpha_prime_x, waveSH_PML.a_x, waveSH_PML.b_x, waveSH_PML.d_x_half, waveSH_PML.K_x_half, waveSH_PML.alpha_prime_x_half, waveSH_PML.a_x_half, 
                 waveSH_PML.b_x_half, waveSH_PML.d_y, waveSH_PML.K_y, waveSH_PML.alpha_prime_y, waveSH_PML.a_y, waveSH_PML.b_y, waveSH_PML.d_y_half, waveSH_PML.K_y_half, waveSH_PML.alpha_prime_y_half, 
                 waveSH_PML.a_y_half, waveSH_PML.b_y_half);
}

/* allocate memory for SH material parameters */
alloc_matSH(&matSH);

/* allocate memory for SH FWI parameters */
alloc_fwiSH(&fwiSH);

/* allocate memory for PSV MPI variables */
alloc_mpiPSV(&mpiPSV);

/* Variables for l-BFGS method */
if(GRAD_METHOD==2){

  NLBFGS_class = 3;                 /* number of parameter classes */

  NLBFGS_vec = NLBFGS_class*NX*NY;  /* length of one LBFGS-parameter class */
  LBFGS_pointer = 1;                /* initiate pointer in the cyclic LBFGS-vectors */
  
  y_LBFGS  =  vector(1,NLBFGS_vec*NLBFGS);
  s_LBFGS  =  vector(1,NLBFGS_vec*NLBFGS);

  q_LBFGS  =  vector(1,NLBFGS_vec);
  r_LBFGS  =  vector(1,NLBFGS_vec);

  rho_LBFGS = vector(1,NLBFGS);
  alpha_LBFGS = vector(1,NLBFGS);
  beta_LBFGS = vector(1,NLBFGS);
  
}

/* Variables for PCG method */
if(GRAD_METHOD==1){

  PCG_class = 3;                 /* number of parameter classes */ 
  PCG_vec = PCG_class*NX*NY;  	 /* length of one PCG-parameter class */  
 
}

taper_coeff=  matrix(1,NY,1,NX);

/* memory for source position definition */
acq.srcpos1=fmatrix(1,8,1,1);

/* memory of L2 norm */
L2t = dvector(1,4);
epst1 = vector(1,3);
	
fprintf(FP," ... memory allocation for PE %d was successfull.\n\n", MYID);

/* Holberg coefficients for FD operators*/
hc = holbergcoeff();

MPI_Barrier(MPI_COMM_WORLD);

/* Reading source positions from SOURCE_FILE */ 	
acq.srcpos=sources(&nsrc);
nsrc_glob=nsrc;


/* create model grids */
if (READMOD) readmod_visc_SH(matSH.prho,matSH.pu,matSH.ptaus,matSH.peta);
/*else model(matPSV.prho,matPSV.ppi,matPSV.pu,matPSV.ptaus,matPSV.ptaup,matPSV.peta);*/


/* check if the FD run will be stable and free of numerical dispersion */
checkfd_visc_SH(FP,matSH.prho,matSH.pu,matSH.ptaus,matSH.peta,hc);


if(GRAVITY==1 || GRAVITY==2){
 
  /* read station positions */
  MPI_Barrier(MPI_COMM_WORLD);
  gravpos=read_grav_pos(&ngrav);

  /* define model and residual data vector for gz (z-component of the gravity field) */
  gz_mod = vector(1,ngrav);
  gz_res = vector(1,ngrav);

  /* only forward modelling of gravity data */
  if(GRAVITY==1){

    /* global density model */
    rho_grav =  matrix(1,NYG,1,NXG);
    rho_grav_ext =  matrix(1,nygrav,1,nxgrav);

    read_density_glob(rho_grav,1);
    extend_mod(rho_grav,rho_grav_ext,nxgrav,nygrav);
    grav_mod(rho_grav_ext,ngrav,gravpos,gz_mod,nxgrav,nygrav,NZGRAV);

    free_matrix(rho_grav,1,NYG,1,NXG);
    free_matrix(rho_grav_ext,1,nygrav,1,nxgrav);

  }

  if(GRAVITY==2){
    grad_grav =  matrix(1,NY,1,NX);
  }

} 
      
SHOTINC=1;
    
iter_true=1;

/* Begin of FWI-workflow */
for(nstage=1;nstage<=stagemax;nstage++){

/* read workflow input file *.inp */
FP_stage=fopen(FILEINP1,"r");
read_par_inv(FP_stage,nstage,stagemax);
/*fclose(FP_stage);*/

if((EPRECOND==1)||(EPRECOND==3)){
  Ws = matrix(1,NY,1,NX); /* total energy of the source wavefield */
  Wr = matrix(1,NY,1,NX); /* total energy of the receiver wavefield */
  We = matrix(1,NY,1,NX); /* total energy of source and receiver wavefield */
}

/* Variables for PCG method */
if(GRAD_METHOD==1){  
  PCG_old  =  vector(1,PCG_vec);
  PCG_new  =  vector(1,PCG_vec);
  PCG_dir  =  vector(1,PCG_vec);
}

FC=FC_END;

iter=1;
/* --------------------------------------
 * Begin of Full Waveform iteration loop
 * -------------------------------------- */
while(iter<=ITERMAX){

      /* Apply random objective waveform inversion */
      if(ROWI){
      
         /* fetch random number on MYID==0 */
         if(MYID==0){
      
            /* initialize random number generator */
      	    srand((unsigned)time(NULL));
      
      	    /* generate random number between 1 and 100 */
            ra = rand();
      	    ra1 = (ra % 100) + 1;
            
         }
      
         /* broadcast random number over all MPI processes */	       
         MPI_Barrier(MPI_COMM_WORLD);
         MPI_Bcast(&ra1,1,MPI_INT,0,MPI_COMM_WORLD);
      
         if(ra1<=50){LNORM=8;}
	 if(ra1>50){LNORM=2;}
      
         if(MYID==0){
            printf("ra1 = %d \t LNORM = %d \n", ra1, LNORM);      
         }
      
      }
        
      MPI_Barrier(MPI_COMM_WORLD);

if(GRAD_METHOD==2){
  
  /* increase pointer to LBFGS-vector*/
  if(iter>2){
    LBFGS_pointer++;
  }
  
  /* if LBFGS-pointer > NLBFGS -> set LBFGS_pointer=1 */ 
  if(LBFGS_pointer>NLBFGS){LBFGS_pointer=1;}

}

if (MYID==0)
   {
   time2=MPI_Wtime();
   fprintf(FP,"\n\n\n ------------------------------------------------------------------\n");
   fprintf(FP,"\n\n\n                   TDFWI ITERATION %d \t of %d \n",iter,ITERMAX);
   fprintf(FP,"\n\n\n ------------------------------------------------------------------\n");
   }

/* For the calculation of the material parameters between gridpoints
   they have to be averaged. For this, values lying at 0 and NX+1,
   for example, are required on the local grid. These are now copied from the
   neighbouring grids */

matcopy_SH(matSH.prho,matSH.pu,matSH.ptaus);


MPI_Barrier(MPI_COMM_WORLD);

av_mu_SH(matSH.pu, matSH.puip, matSH.pujp, matSH.prho);
inv_rho_SH(matSH.prho, matSH.prhoi);
av_tau(matSH.ptaus,matSH.ptausipjp);

/* Preparing memory variables for update_s (viscoelastic) */
prepare_update_s_visc_SH(matSH.etajm, matSH.etaip, matSH.peta, matSH.fipjp, matSH.pujp, matSH.puip, 
			 matSH.prho, matSH.ptaus, matSH.ptausipjp, matSH.f, matSH.g, matSH.bip, matSH.bjm, 
			 matSH.cip, matSH.cjm, matSH.dip, matSH.d, matSH.e); 

if(iter_true==1){

    for (i=1;i<=NX;i=i+IDX){ 
	for (j=1;j<=NY;j=j+IDY){
	
	if(INVMAT1==1){
	
	  fwiSH.Vs0[j][i] = matSH.pu[j][i];
	  fwiSH.Rho0[j][i] = matSH.prho[j][i];
	  fwiSH.Taus0[j][i] = matSH.ptaus[j][i];

        }
	  
                 
		 
	if(INVMAT1==2){
        
	  fwiSH.Vs0[j][i] = sqrt(matSH.pu[j][i]*matSH.prho[j][i]);
	  fwiSH.Rho0[j][i] = matSH.prho[j][i];
	  fwiSH.Taus0[j][i] = matSH.ptaus[j][i];
	
	}
	 
	if(INVMAT1==3){
        
	  fwiSH.Vs0[j][i] = matSH.pu[j][i];
	  fwiSH.Rho0[j][i] = matSH.prho[j][i];
	  fwiSH.Taus0[j][i] = matSH.ptaus[j][i];
	
	}  
	
    }
    }

/* ---------------------------------------------- */
/* calculate minimum and maximum model parameters */
/* ---------------------------------------------- */

	Vs_max = 0.0;
	rho_max = 0.0;
	taus_max = 0.0;
	
	Vs_min = 1e10;
	rho_min = 1e10;
	taus_min = 1e10; 
	
	Vs_avg = 0.0;
	rho_avg = 0.0; 
	 
        for (i=1;i<=NX;i=i+IDX){
           for (j=1;j<=NY;j=j+IDY){
	  
		 /* calculate maximum Vs */
		 if(matSH.pu[j][i] > Vs_max){
		     Vs_max = matSH.pu[j][i];
		 }
		 
		 /* calculate minimum Vs */
		 if(matSH.pu[j][i] < Vs_min){
		     Vs_min = matSH.pu[j][i];
		 }
		 
		 /* calculate average vs value */
		 Vs_avg += matSH.pu[j][i];		 
		 
		 /* calculate maximum rho */
		 if(matSH.prho[j][i] > rho_max){
		     rho_max = matSH.prho[j][i];
		 }

		 /* calculate minimum rho */
		 if(matSH.prho[j][i] < rho_min){
		     rho_min = matSH.prho[j][i];
		 }
		 
		 /* calculate average rho value */
		 rho_avg += matSH.prho[j][i];

		 /* calculate maximum taus */
		 if(matSH.ptaus[j][i] > taus_max){
		     taus_max = matSH.ptaus[j][i];
		 }

		 /* calculate minimum taus */
		 if(matSH.ptaus[j][i] < taus_min){
		     taus_min = matSH.ptaus[j][i];
		 }

	
           }
        }

	/* calculate minimum Vs, rho and taus of all CPUs*/
	
	Vs_sum = 0.0;
        MPI_Allreduce(&Vs_min,&Vs_sum,1,MPI_FLOAT,MPI_MAX,MPI_COMM_WORLD);
        C_vs_min=Vs_sum;
	
	rho_sum = 0.0;
        MPI_Allreduce(&rho_min,&rho_sum,1,MPI_FLOAT,MPI_MAX,MPI_COMM_WORLD);
        C_rho_min=rho_sum;

	taus_sum = 0.0;
        MPI_Allreduce(&taus_min,&taus_sum,1,MPI_FLOAT,MPI_MAX,MPI_COMM_WORLD);
        C_taus_min=taus_sum;
		
	/*if(MYID==0){
           printf("Vs_min = %e \t rho_min = %e \t taus_min = %e \n ",C_vs_min, C_rho_min, C_taus_min);	
	}*/
		
        /* calculate maximum Vs, rho and taus of all CPUs*/
	
	Vs_sum = 0.0;
        MPI_Allreduce(&Vs_max,&Vs_sum,1,MPI_FLOAT,MPI_MAX,MPI_COMM_WORLD);
        Vs_max=Vs_sum;
	
	rho_sum = 0.0;
        MPI_Allreduce(&rho_max,&rho_sum,1,MPI_FLOAT,MPI_MAX,MPI_COMM_WORLD);
        rho_max=rho_sum;

	taus_sum = 0.0;
        MPI_Allreduce(&taus_max,&taus_sum,1,MPI_FLOAT,MPI_MAX,MPI_COMM_WORLD);
        taus_max=taus_sum;
	
	/* calculate average Vs, rho and taus of all CPUs*/
	
	Vs_sum = 0.0;
        MPI_Allreduce(&Vs_avg,&Vs_sum,1,MPI_FLOAT,MPI_SUM,MPI_COMM_WORLD);
        Vs_avg=Vs_sum / (NXG*NYG);
	
	rho_sum = 0.0;
        MPI_Allreduce(&rho_avg,&rho_sum,1,MPI_FLOAT,MPI_SUM,MPI_COMM_WORLD);
        rho_avg=rho_sum / (NXG*NYG);

		
	/*if(MYID==0){
           printf("Vs_max = %e \t rho_max = %e \t taus_max = %e \n ",Vs_max, rho_max, taus_max);	
	}*/
	
	if(MYID==0){
           printf("Vs_avg = %e \t rho_max = %e \n ",Vs_avg, rho_avg);	
	}
	
	/* scaling factor for gradients normalized relative to mininum and maximum values*/
	/*C_vs = Vs_max - C_vs_min;
	C_rho = rho_max - C_rho_min;
	C_taus = taus_max - C_taus_min;*/
	
	/* scaling factor for gradients normalized relative to maximum values*/
	/*C_vs = Vs_max;
	C_rho = rho_max;
	C_taus = taus_max;*/
	
	/* scaling factor for gradients normalized relative to average values*/
	C_vs = Vs_avg;
	C_rho = rho_avg;
	
	C_vs_min = 0.0;
	C_rho_min = 0.0;
	C_taus_min = 0.0;

	/* scaling factor for gradients not normalized */
	/*C_vs = 1.0;
	C_rho = 1.0;
	C_taus = 1.0;
	
	C_vs_min = 0.0;
	C_rho_min = 0.0;
	C_taus_min = 0.0;*/
			       	
}

/* Open Log File for L2 norm */
if(MYID==0){
  if(iter_true==1){
    FPL2=fopen(MISFIT_LOG_FILE,"w");
  }

  if(iter_true>1){
    FPL2=fopen(MISFIT_LOG_FILE,"a");
  }
}

/* ---------------------------------------------------------------------------------------------------- */
/* --------- Calculate gradient and objective function using the adjoint state method ----------------- */
/* ---------------------------------------------------------------------------------------------------- */

L2sum = grad_obj_sh(&waveSH, &waveSH_PML, &matSH, &fwiSH, &mpiPSV, &seisSH, &seisSHfwi, &acq, hc, iter, nsrc, ns, ntr, ntr_glob, 
nsrc_glob, nsrc_loc, ntr_loc, nstage, We, Ws, Wr, taper_coeff, hin, DTINV_help, req_send, req_rec);

L2t[1]=L2sum;
L2t[4]=L2sum;

/* Interpolate missing spatial gradient values in case IDXI > 1 || IDXY > 1 */
/* ------------------------------------------------------------------------ */

if((IDXI>1)||(IDYI>1)){

   interpol(IDXI,IDYI,fwiSH.waveconv_u,1);
   interpol(IDXI,IDYI,fwiSH.waveconv_rho,1);

}

/* assemble SH gradients */
ass_gradSH_visc(&fwiSH,&matSH,iter);

/* Apply diagonal elements of inverse Pseudo-Hessian to gradients */
/*if(EPRECOND==4){
   for (i=1;i<=NX;i=i+IDX){
       for (j=1;j<=NY;j=j+IDY){

             fwiSH.waveconv_u[j][i] = fwiSH.ihess_vs2[j][i] * fwiSH.waveconv_u[j][i];
	   fwiSH.waveconv_rho[j][i] = fwiSH.ihess_rho2[j][i] * fwiSH.waveconv_rho[j][i];
	    fwiSH.waveconv_ts[j][i] = fwiSH.ihess_ts2[j][i] * fwiSH.waveconv_ts[j][i];
    
       }
   }
}*/

/* Preconditioning of gradients after shot summation and smoothing */
precond_SH(&fwiSH,&acq,nsrc,ntr_glob,taper_coeff,FP_GRAV);

/* apply 2D Median filter to gradients */
if(GRAD_FILTER==1){
    median_model(fwiSH.waveconv_u,FILT_SIZE_GRAD);
    median_model(fwiSH.waveconv_rho,FILT_SIZE_GRAD);
}

/* smooth gradients using Gaussian filter */
smooth_grad(fwiSH.waveconv_u, matSH.pu);
smooth_grad(fwiSH.waveconv_rho, matSH.pu);

/* Use preconditioned conjugate gradient optimization method */
if(GRAD_METHOD==1){

    /* calculate steepest descent direction */
    descent(fwiSH.waveconv_u,fwiSH.gradp_u);
    descent(fwiSH.waveconv_rho,fwiSH.gradp_rho);

    /* store current gradients in PCG_new vector */
    store_PCG_SH_visc(PCG_new,fwiSH.gradp_u,fwiSH.gradp_rho,fwiSH.gradp_ts);

    /* apply PCG method */
    PCG(PCG_new,PCG_old,PCG_dir,PCG_class);

    /* extract CG-search directions */
    extract_PCG_SH_visc(PCG_dir,fwiSH.waveconv_u,fwiSH.waveconv_rho,fwiSH.waveconv_ts);

    /* store old gradients in PCG_old vector */
    store_PCG_SH_visc(PCG_old,fwiSH.gradp_u,fwiSH.gradp_rho,fwiSH.gradp_ts);

    /* steepest descent direction -> gradient direction */
    descent(fwiSH.waveconv_u,fwiSH.waveconv_u);
    descent(fwiSH.waveconv_rho,fwiSH.waveconv_rho);

}

/* Use l-BFGS optimization */
if(GRAD_METHOD==2){ 

    /* store models and gradients in l-BFGS vectors */
    store_LBFGS_SH_visc(taper_coeff, nsrc, acq.srcpos, acq.recpos, ntr_glob, iter, fwiSH.waveconv_u, fwiSH.gradp_u, fwiSH.waveconv_rho, 
		    fwiSH.gradp_rho, fwiSH.waveconv_ts, fwiSH.gradp_ts, y_LBFGS, s_LBFGS, q_LBFGS, matSH.pu, matSH.prho, matSH.ptaus, NXNYI, LBFGS_pointer, NLBFGS, NLBFGS_vec);

    /* apply l-BFGS optimization */
    LBFGS(iter, y_LBFGS, s_LBFGS, rho_LBFGS, alpha_LBFGS, q_LBFGS, r_LBFGS, beta_LBFGS, LBFGS_pointer, NLBFGS, NLBFGS_vec);

    /* extract gradients and save old models/gradients for next l-BFGS iteration */
    extract_LBFGS_SH_visc(iter, fwiSH.waveconv_u, fwiSH.gradp_u, fwiSH.waveconv_rho, fwiSH.gradp_rho, fwiSH.waveconv_ts, fwiSH.gradp_ts, matSH.pu, matSH.prho, matSH.ptaus, r_LBFGS);

}

opteps_vs=0.0;
opteps_rho=0.0;
opteps_ts=0.0;

/* ============================================================================================================================*/
/* =============================================== test loop L2 ===============================================================*/
/* ============================================================================================================================*/

/* set min_iter_help to initial global value of MIN_ITER */
if(iter==1){min_iter_help=MIN_ITER;}

/* Estimate optimum step length ... */

/* ... by line search (parabolic fitting) */
eps_scale = step_length_est_sh(&waveSH,&waveSH_PML,&matSH,&fwiSH,&mpiPSV,&seisSH,&seisSHfwi,&acq,hc,iter,nsrc,ns,ntr,ntr_glob,epst1,L2t,nsrc_glob,nsrc_loc,&step1,&step3,nxgrav,nygrav,ngrav,gravpos,gz_mod,NZGRAV,
                                ntr_loc,Ws,Wr,hin,DTINV_help,req_send,req_rec);

/* no model update due to steplength estimation failed or update with the smallest steplength if the number of iteration is smaller than the minimum number of iteration per
frequency MIN_ITER */
if((iter>min_iter_help)&&(step1==0)){ 
	eps_scale=0.0;
	opteps_vp=0.0;
}
else{
	opteps_vp=eps_scale;
}

/* write log-parameter files */
if(MYID==0){
printf("MYID = %d \t opteps_vp = %e \t opteps_vs = %e \t opteps_rho = %e \n",MYID,opteps_vp,opteps_vs,opteps_rho);
printf("MYID = %d \t L2t[1] = %e \t L2t[2] = %e \t L2t[3] = %e \t L2t[4] = %e \n",MYID,L2t[1],L2t[2],L2t[3],L2t[4]);
printf("MYID = %d \t epst1[1] = %e \t epst1[2] = %e \t epst1[3] = %e \n",MYID,epst1[1],epst1[2],epst1[3]);

/*output of log file for combined inversion*/
if(iter_true==1 && GRAVITY){
    LAMBDA = fopen("gravity/lambda.dat","w");
}
if(iter_true>1 && GRAVITY){
    LAMBDA = fopen("gravity/lambda.dat","a");
}

if(GRAVITY){
    fprintf(LAMBDA,"%d \t %d \t %e \t %e \t %e \t %e \t %e \t %e \t %e \n",nstage,iter,LAM_GRAV,L2sum,L2_grav,L2t[4],LAM_GRAV_GRAD,FWImax_all,GRAVmax_all);
    fclose(LAMBDA);
}

}

if(MYID==0){
if (TIME_FILT==0){
	fprintf(FPL2,"%e \t %e \t %e \t %e \t %e \t %e \t %e \t %e \t %d \n",opteps_vp,epst1[1],epst1[2],epst1[3],L2t[1],L2t[2],L2t[3],L2t[4],nstage);}
else{
	fprintf(FPL2,"%e \t %e \t %e \t %e \t %e \t %e \t %e \t %e \t %f \t %f \t %d \n",opteps_vp,epst1[1],epst1[2],epst1[3],L2t[1],L2t[2],L2t[3],L2t[4],FC_START,FC,nstage);}}


/* saving history of final L2*/
L2_hist[iter]=L2t[4];
s=0;

/* calculate optimal change in the material parameters */
eps_true=calc_mat_change_test_SH_visc(fwiSH.waveconv_rho,fwiSH.waveconv_u,fwiSH.waveconv_ts,fwiSH.prho_old,matSH.prho,fwiSH.pu_old,matSH.pu,fwiSH.ptaus_old,matSH.ptaus,iter,1,eps_scale,0);

/* apply 2D Median filter to velocity and density model */
if(MODEL_FILTER==1){
    median_model(matSH.prho,FILT_SIZE);
    median_model(matSH.pu,FILT_SIZE);
}

if(MYID==0){	
/*	fprintf(FPL2,"=============================================================\n");
	fprintf(FPL2,"=============================================================\n");
	fprintf(FPL2,"STATISTICS FOR ITERATION STEP %d \n",iter);
	fprintf(FPL2,"=============================================================\n");
	fprintf(FPL2,"=============================================================\n");*/
/*	fprintf(FPL2,"Low-pass filter at %e Hz\n",freq);
	fprintf(FPL2,"----------------------------------------------\n");
*/	/*fprintf(FPL2,"L2 at iteration step n = %e \n",L2);*/
/*        fprintf(FPL2,"%e \t %e \t %e \t %e \t %e \t %e \t %e \t %e \n",EPSILON,EPSILON_u,EPSILON_rho,L2t[4],betaVp,betaVs,betarho,sqrt(C_vp));*/

	/*fprintf(FPL2,"----------------------------------------------\n");*/
/*	fprintf(FPL2,"=============================================================\n");
	fprintf(FPL2,"=============================================================\n\n\n");*/
}

if(MYID==0){
  fclose(FPL2);
}

if (iter>min_iter_help){

float diff=0.0, pro=PRO;

/* calculating differnce of the actual L2 and before two iterations, dividing with L2_hist[iter-2] provide changing in procent*/
diff=fabs((L2_hist[iter-2]-L2_hist[iter])/L2_hist[iter-2]);
	
	if((diff<=pro)||(step3==1)){
        
        	/* output of the model at the end of given FWI stage */
		if(INV_MOD_OUT==0){
        	    model_freq_out_SH_visc(matSH.prho,matSH.pu,matSH.ptaus,nstage,FC);
		}

		s=1;
		min_iter_help=0;
		min_iter_help=iter+MIN_ITER;
		iter=0;

        	if(GRAD_METHOD==1){
	  		zero_PCG(PCG_old, PCG_new, PCG_dir, PCG_vec);
		}

        	if(GRAD_METHOD==2){
	  		zero_LBFGS(NLBFGS, NLBFGS_vec, y_LBFGS, s_LBFGS, q_LBFGS, r_LBFGS, alpha_LBFGS, beta_LBFGS, rho_LBFGS);
          		LBFGS_pointer = 1;  
		}

        	if(MYID==0){
			if(step3==1){
			        printf("\n Steplength estimation failed step3=%d \n Changing to next FWI stage \n",step3);
			}
			else{
  				printf("\n Reached the abort criterion of pro=%e and diff=%e \n Changing to next FWI stage \n",pro,diff);
			}
	
		}
		break;
	}
}

/* output of the model after each FWI iteration */
if(INV_MOD_OUT==1){
    model_it_out_SH_visc(matSH.prho,matSH.pu,matSH.ptaus,nstage,iter,FC);
}

iter++;
iter_true++;

/* ====================================== */
} /* end of fullwaveform iteration loop*/
/* ====================================== */

/* Deallocate PCG vectors */
if(GRAD_METHOD==1){
  free_vector(PCG_old,1,PCG_vec);
  free_vector(PCG_new,1,PCG_vec);
  free_vector(PCG_dir,1,PCG_vec);
}

/* Deallocate EPRECOND matrices */
if(EPRECOND==1 || EPRECOND==3){
   free_matrix(Ws,1,NY,1,NX);
   free_matrix(Wr,1,NY,1,NX);
   free_matrix(We,1,NY,1,NX);
}

} /* End of FWI-workflow loop */

/* deallocate memory for SH forward problem */
dealloc_SH(&waveSH,&waveSH_PML);

/* deallocation of memory */
free_matrix(fwiSH.Vs0,-nd+1,NY+nd,-nd+1,NX+nd);
free_matrix(fwiSH.Rho0,-nd+1,NY+nd,-nd+1,NX+nd);
free_matrix(fwiSH.Taus0,-nd+1,NY+nd,-nd+1,NX+nd);

free_matrix(matSH.prho,-nd+1,NY+nd,-nd+1,NX+nd);
free_matrix(fwiSH.prho_old,-nd+1,NY+nd,-nd+1,NX+nd);

free_matrix(matSH.pu,-nd+1,NY+nd,-nd+1,NX+nd);
free_matrix(fwiSH.pu_old,-nd+1,NY+nd,-nd+1,NX+nd);
free_matrix(matSH.puipjp,-nd+1,NY+nd,-nd+1,NX+nd);
free_matrix(matSH.puip,-nd+1,NY+nd,-nd+1,NX+nd);
free_matrix(matSH.pujp,-nd+1,NY+nd,-nd+1,NX+nd);

free_matrix(fwiSH.ptaus_old,-nd+1,NY+nd,-nd+1,NX+nd);

free_matrix(mpiPSV.bufferlef_to_rig,1,NY,1,fdo3);
free_matrix(mpiPSV.bufferrig_to_lef,1,NY,1,fdo3);
free_matrix(mpiPSV.buffertop_to_bot,1,NX,1,fdo3);
free_matrix(mpiPSV.bufferbot_to_top,1,NX,1,fdo3);

free_vector(hc,0,6);

free_matrix(fwiSH.gradg_rho,-nd+1,NY+nd,-nd+1,NX+nd);
free_matrix(fwiSH.gradp_rho,-nd+1,NY+nd,-nd+1,NX+nd);
free_matrix(fwiSH.waveconv_rho,-nd+1,NY+nd,-nd+1,NX+nd);
free_matrix(fwiSH.waveconv_rho_s,-nd+1,NY+nd,-nd+1,NX+nd);
free_matrix(fwiSH.waveconv_rho_shot,-nd+1,NY+nd,-nd+1,NX+nd);

free_matrix(fwiSH.gradg_u,-nd+1,NY+nd,-nd+1,NX+nd);
free_matrix(fwiSH.gradp_u,-nd+1,NY+nd,-nd+1,NX+nd);
free_matrix(fwiSH.waveconv_u,-nd+1,NY+nd,-nd+1,NX+nd);
free_matrix(fwiSH.waveconv_mu,-nd+1,NY+nd,-nd+1,NX+nd);
free_matrix(fwiSH.waveconv_u_shot,-nd+1,NY+nd,-nd+1,NX+nd);

free_matrix(fwiSH.gradg_ts,-nd+1,NY+nd,-nd+1,NX+nd);
free_matrix(fwiSH.gradp_ts,-nd+1,NY+nd,-nd+1,NX+nd);
free_matrix(fwiSH.waveconv_ts,-nd+1,NY+nd,-nd+1,NX+nd);
free_matrix(fwiSH.waveconv_ts_s,-nd+1,NY+nd,-nd+1,NX+nd);
free_matrix(fwiSH.waveconv_ts_shot,-nd+1,NY+nd,-nd+1,NX+nd);

free_vector(fwiSH.forward_prop_sxz,1,NY*NX*NT);
free_vector(fwiSH.forward_prop_syz,1,NY*NX*NT);
free_vector(fwiSH.forward_prop_rho_z,1,NY*NX*NT);

free_matrix(fwiSH.forward_prop_rxz,1,NY*NX*NT,1,L);
free_matrix(fwiSH.forward_prop_ryz,1,NY*NX*NT,1,L);

if(EPRECOND==4){
   free_matrix(fwiSH.hess_mu2,-nd+1,NY+nd,-nd+1,NX+nd);
   free_matrix(fwiSH.hess_rho2,-nd+1,NY+nd,-nd+1,NX+nd);
   free_matrix(fwiSH.hess_ts2,-nd+1,NY+nd,-nd+1,NX+nd);
   free_matrix(fwiSH.hess_vs2,-nd+1,NY+nd,-nd+1,NX+nd);
   free_matrix(fwiSH.hess_rho2p,-nd+1,NY+nd,-nd+1,NX+nd);
   
   free_matrix(fwiSH.hess_muts,-nd+1,NY+nd,-nd+1,NX+nd);
   free_matrix(fwiSH.hess_murho,-nd+1,NY+nd,-nd+1,NX+nd);
   free_matrix(fwiSH.hess_tsrho,-nd+1,NY+nd,-nd+1,NX+nd);   
}

if (nsrc_loc>0){	
	free_matrix(acq.signals,1,nsrc_loc,1,NT);
	free_matrix(acq.srcpos_loc,1,8,1,nsrc_loc);
	free_matrix(acq.srcpos_loc_back,1,6,1,nsrc_loc);
}		   

 /* free memory for global source positions */
 free_matrix(acq.srcpos,1,8,1,nsrc);

 /* free memory for source position definition */
 free_matrix(acq.srcpos1,1,8,1,1);
 
 /* free memory for abort criterion */
 free_dvector(L2_hist,1,1000);
 		
 free_dvector(L2t,1,4);
 free_vector(epst1,1,3);

 if(READREC!=2){

    if (SEISMO) free_imatrix(acq.recpos,1,3,1,ntr_glob);

    if ((ntr>0) && (SEISMO)){

            free_imatrix(acq.recpos_loc,1,3,1,ntr);
            acq.recpos_loc = NULL;
 
            switch (SEISMO){
            case 1 : /* particle velocities only */
                    free_matrix(seisSH.sectionvz,1,ntr,1,ns);
                    seisSH.sectionvz=NULL;
                    break;

             }

    }

    free_matrix(seisSHfwi.sectionread,1,ntr_glob,1,ns);
    free_ivector(acq.recswitch,1,ntr);
    
    if(QUELLTYPB){
       free_matrix(seisSHfwi.sectionvzdata,1,ntr,1,ns);
       free_matrix(seisSHfwi.sectionvzdiff,1,ntr,1,ns);
       free_matrix(seisSHfwi.sectionvzdiffold,1,ntr,1,ns);
    }

    if(SEISMO){
        free_matrix(seisSH.fulldata_vz,1,ntr_glob,1,NT); 
    }
 
 }

 free_ivector(DTINV_help,1,NT);
 
 /* free memory for viscoelastic modeling variables */ 
free_matrix(matSH.ptaus,-nd+1,NY+nd,-nd+1,NX+nd);
free_matrix(matSH.ptausipjp,-nd+1,NY+nd,-nd+1,NX+nd);
free_vector(matSH.peta,1,L);
free_vector(matSH.etaip,1,L);
free_vector(matSH.etajm,1,L);
free_vector(matSH.bip,1,L);
free_vector(matSH.bjm,1,L);
free_vector(matSH.cip,1,L);
free_vector(matSH.cjm,1,L);
free_matrix(matSH.f,-nd+1,NY+nd,-nd+1,NX+nd);
free_matrix(matSH.fipjp,-nd+1,NY+nd,-nd+1,NX+nd);
free_matrix(matSH.g,-nd+1,NY+nd,-nd+1,NX+nd);
free_f3tensor(matSH.dip,-nd+1,NY+nd,-nd+1,NX+nd,1,L);
free_f3tensor(matSH.d,-nd+1,NY+nd,-nd+1,NX+nd,1,L);
free_f3tensor(matSH.e,-nd+1,NY+nd,-nd+1,NX+nd,1,L);


if(GRAVITY){

  free_matrix(gravpos,1,2,1,ngrav);
  free_vector(gz_mod,1,ngrav);
  free_vector(gz_res,1,ngrav);

  if(GRAVITY==2){
    free_matrix(grad_grav,1,NY,1,NX);
  }

}
 
/* de-allocate buffer for messages */
MPI_Buffer_detach(buff_addr,&buffsize);

MPI_Barrier(MPI_COMM_WORLD);

if (MYID==0){
	fprintf(FP,"\n **Info from main (written by PE %d): \n",MYID);
	fprintf(FP," CPU time of program per PE: %li seconds.\n",clock()/CLOCKS_PER_SEC);
	time8=MPI_Wtime();
	fprintf(FP," Total real time of program: %4.2f seconds.\n",time8-time1);
	time_av_v_update=time_av_v_update/(double)NT;
	time_av_s_update=time_av_s_update/(double)NT;
	time_av_v_exchange=time_av_v_exchange/(double)NT;
	time_av_s_exchange=time_av_s_exchange/(double)NT;
	time_av_timestep=time_av_timestep/(double)NT;
	/* fprintf(FP," Average times for \n");
	fprintf(FP," velocity update:  \t %5.3f seconds  \n",time_av_v_update);
	fprintf(FP," stress update:  \t %5.3f seconds  \n",time_av_s_update);
	fprintf(FP," velocity exchange:  \t %5.3f seconds  \n",time_av_v_exchange);
	fprintf(FP," stress exchange:  \t %5.3f seconds  \n",time_av_s_exchange);
	fprintf(FP," timestep:  \t %5.3f seconds  \n",time_av_timestep);*/		
}

fclose(FP);


}



